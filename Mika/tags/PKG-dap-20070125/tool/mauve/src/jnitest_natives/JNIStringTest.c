/**************************************************************************
* Copyright  (c) 2001 by Acunia N.V. All rights reserved.                 *
*                                                                         *
* This software is copyrighted by and is the sole property of Acunia N.V. *
* and its licensors, if any. All rights, title, ownership, or other       *
* interests in the software remain the property of Acunia N.V. and its    *
* licensors, if any.                                                      *
*                                                                         *
* This software may only be used in accordance with the corresponding     *
* license agreement. Any unauthorized use, duplication, transmission,     *
*  distribution or disclosure of this software is expressly forbidden.    *
*                                                                         *
* This Copyright notice may not be removed or modified without prior      *
* written consent of Acunia N.V.                                          *
*                                                                         *
* Acunia N.V. reserves the right to modify this software without notice.  *
*                                                                         *
*   Acunia N.V.                                                           *
*   Vanden Tymplestraat 35      info@acunia.com                           *
*   3000 Leuven                 http://www.acunia.com                     *
*   Belgium - EUROPE                                                      *
**************************************************************************/


/* DO NOT EDIT THIS FILE - it is machine generated */
#include <stdio.h>
#include <jni.h> //JNI definitions
#include <stdlib.h> //malloc definitions
//#include "gnu_testlet_wonka_jni_JNIStringTest.h"


/****************************************************************************************************************
* implementations for the string constructors NewString and NewStringUTF                                        *
****************************************************************************************************************/
/**
 * Class:     JNIStringTest
 * Method:    nativeUnicodeHello
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUnicodeHello
  (JNIEnv *env, jobject obj)
{
  const jchar hello[5] = {(jchar)'h',(jchar)'e',(jchar)'l',(jchar)'l',(jchar)'o'};
  return ((*env)->NewString(env,hello,5));
}

/**
 * Class:     JNIStringTest
 * Method:    nativeUTFHello
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUTFHello
  (JNIEnv *env, jobject obj)
{
  const char* hello = "hello";
  return ((*env)->NewStringUTF(env,hello));
}

/**
 * Class:     JNIStringTest
 * Method:    nativeUnicodeBuildString
 * Signature: (IC)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUnicodeBuildString
  (JNIEnv *env, jobject obj, jint length, jchar ch)
{
  jstring newstring;
  jchar *str;
  int i;

  str = (jchar*)malloc((size_t)(length*sizeof(jchar)));
  for(i=0; i<length; i++)
    str[i] = ch;

  newstring = (*env)->NewString(env, str, length);
  free(str);
  return newstring;
}

/**
 * Class:     JNIStringTest
 * Method:    nativeUTFBuildString
 * Signature: (IB)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUTFBuildString
  (JNIEnv *env, jobject obj, jint length, jbyte b)
{
  jstring newstring;
  char *str;
  int i;

  str = malloc((size_t)(length+1));
  for(i=0; i<length; i++)
    str[i] = b;
  str[length] = 0;

  newstring = (*env)->NewStringUTF(env, str);
  free(str);
  return newstring;
}


/****************************************************************************************************************
* testing GetStringLength and GetStringUTFLength                                     *
****************************************************************************************************************/
/**
 * Class:     JNIStringTest
 * Method:    nativeUnicodeLength
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUnicodeLength
  (JNIEnv *env, jobject obj, jstring source)
{ return((jint)((*env)->GetStringLength(env, source)));}

/**
 * Class:     JNIStringTest
 * Method:    nativeUTFLength
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUTFLength
  (JNIEnv *env, jobject obj, jstring source)
{ return((jint)((*env)->GetStringUTFLength(env, source)));}



/****************************************************************************************************************
* implementations for string access using GetStringChars/ReleaseStringchars and  GetStringUTFChars/ReleaseStringUTFchars                                       *
****************************************************************************************************************/
/**
 * Class:     JNIStringTest
 * Method:    nativeUnicodeCountNonAscii
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUnicodeCountNonAscii
  (JNIEnv *env, jobject obj, jstring source)
{
  jint nonasciichars = 0;
  int i;

  //access the jstring UTF characters
  jboolean iscopy;
  jsize length = (*env)->GetStringLength(env, source);
  const jchar* ch = (*env)->GetStringChars(env, source, &iscopy);

  // scan for non ascii-7 signs 16-bit jchar values > 0x7f
  for(i=0; i<length; i++)
  {
    if(ch[i] > 127 )
      nonasciichars++;
  }

  // if needed, release the chars again
  if(iscopy)
    (*env)->ReleaseStringChars(env, source, ch);
  return nonasciichars;
}

/**
 * Class:     JNIStringTest
 * Method:    nativeUTFCountNonAscii
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUTFCountNonAscii
  (JNIEnv *env, jobject obj, jstring source)
{
  jint nonasciichars = 0;
  int i;

  //access the jstring UTF characters
  jboolean iscopy;
  jsize length = (*env)->GetStringUTFLength(env, source);
  //const unsigned char *ch = (*env)->GetStringUTFChars(env, source, &iscopy);
  const jbyte* ch = (*env)->GetStringUTFChars(env, source, &iscopy);
  // scan for non ascii-7 signs (type 10xx xxxx or 110x xxxx, so > 0x7f
  for(i=0; i<length; i++)
  {
    if(ch[i] <0) //> 127)
      nonasciichars++;
  }

  // if needed, release the chars again
  if(iscopy)
    (*env)->ReleaseStringUTFChars(env, source, ch);
  return nonasciichars;
}



/****************************************************************************************************************
* implementations for string copy using GetStringChars/ReleaseStringchars GetStringUTFChars/ReleaseStringUTFchars                                       *
* and NewString/NewStringUTF
****************************************************************************************************************/
/**
 * Class:     JNIStringTest
 * Method:    nativeUnicodeBuildOnlyAscii
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUnicodeBuildOnlyAscii
  (JNIEnv *env, jobject obj, jstring source)
{
  jstring newstring;
  int i;

  //access the jstring UTF characters
  //access the jstring UTF characters
  jboolean iscopy;
  jsize length = (*env)->GetStringLength(env, source);
  const jchar* ch = (*env)->GetStringChars(env, source, &iscopy);
  const jchar* cstr = (const jchar*)(malloc(length*sizeof(jchar)));
  jchar* str = (jchar*)cstr;
  // scan for non ascii-7 signs 16-bit jchar values > 0x7f
  for(i=0; i<length; i++)
  {
    if(ch[i] > 127 )
    {
      str[i] = (jchar)42; //'*'
//printf("replaced %c at char %d\n",(char)str[i], i);
    }
    else
    {
      str[i] = ch[i];
//printf("copied %c at char %d\n",(char)str[i], i);
    }
  }

  // if needed, release the chars again
  if(iscopy)
    (*env)->ReleaseStringChars(env, source, ch);
  //build the string
  newstring = (*env)->NewString(env,cstr,length);
  free(str);
  //Ok, bring in the cake
  return newstring;
}

/**
 * Class:     JNIStringTest
 * Method:    nativeUTFBuildOnlyAscii
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUTFBuildOnlyAscii
  (JNIEnv *env, jobject obj, jstring source)
{
  jstring newstring;
  int i;

  //access the jstring UTF characters
  //get the mirror string
  jboolean iscopy;
  jsize length = (*env)->GetStringUTFLength(env, source);
  const jbyte *ch = (*env)->GetStringUTFChars(env, source, &iscopy);
  const char*cstr = (const char*)(malloc((size_t)(length +1)) );
  char* str = (char*) cstr;

  // copy byte by byte, replace non-ascii bytes by asterixes
  str[length] = 0;
  for(i=0; i<length; i++)
  {
    if(ch[i] <0)
    {
//      printf( "replacing char %d value %d \n", i, (int)ch[i]);
      str[i] = (char)42; //'*'
    }
    else
    {
      str[i] = (char)ch[i];
//      printf("copying char %c\n",str[i]);
    }
  }

  // Cleanup string and mirror memory
  if(iscopy)
    (*env)->ReleaseStringUTFChars(env, source, ch);
  //assign new string
  newstring = (*env)->NewStringUTF(env, cstr);
  free(str);
  //Ok, bring in the cake
  return newstring;
}



/****************************************************************************************************************
* implementationsDirect string manipulation using GetStringChars/ReleaseStringchars and  GetStringUTFChars/ReleaseStringUTFchars                                       *
****************************************************************************************************************/
/**
 * Class:     JNIStringTest
 * Method:    nativeUTFReplaceNonAscii
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUnicodeReplaceNonAscii
  (JNIEnv *env, jobject obj, jstring source)
{
  int i;

  //access the jstring UTF characters
  //get the mirror string
  //jboolean iscopy; //always return the changed char buffer
  //access the jstring UTF characters
  jboolean iscopy;
  jsize length = (*env)->GetStringLength(env, source);
  const jchar* ch = (*env)->GetStringChars(env, source, &iscopy);
  jchar* str = (jchar*)ch;
  // scan for non ascii-7 signs 16-bit jchar values > 0x7f
  for(i=0; i<length; i++)
  {
    if(ch[i] > 127 )
      str[i] = (jchar)42;
  }

  // if needed, release the chars again
  if(iscopy)
    (*env)->ReleaseStringChars(env, source, ch);
  //Ok, get the goods to sender
  return source;
}

/**
 * Class:     JNIStringTest
 * Method:    nativeUnicodeReplaceNonAscii
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeUTFReplaceNonAscii
  (JNIEnv *env, jobject obj, jstring source)
{
  int i;
  jboolean iscopy;

  jsize length = (*env)->GetStringUTFLength(env, source);
  const jbyte *ch = (*env)->GetStringUTFChars(env, source, &iscopy);
//  const char*cstr = (const char*)(malloc((size_t)(length +1)) );
  char* str = (char*) ch; //cstr;

  // copy byte by byte, replace non-ascii bytes by asterixes
  str[length] = 0;
  for(i=0; i<length; i++)
  {
    if(ch[i] <0)
    {
//      printf( "replacing char %d value %d \n", i, (int)ch[i]);
      str[i] = (char)42; //'*'
    }

  }
  // Cleanup string and mirror memory
  if(iscopy)
    (*env)->ReleaseStringUTFChars(env, source, ch);
  //Ok, get the goods to sender
  return source;
}


/****************************************************************************************************************
* implementations for string access using GetStringCritical/ReleaseStringCritical                          *
****************************************************************************************************************/
/**
 * Class:     JNIStringTest
 * Method:    nativeCriticalCountNonAscii
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeCriticalCountNonAscii
  (JNIEnv *env, jobject obj, jstring source)
{
  jint nonasciichars = 0;
  int i;
  const jchar* ch;

  //access the jstring UTF characters
  jsize length = (*env)->GetStringLength(env, source);
printf("=> Entering GetStringCritical ................................\n");
  ch = (*env)->GetStringCritical(env, source, 0);
printf("=> GetStringCritical done ................................\n");

  // scan for non ascii-7 signs 16-bit jchar values > 0x7f
  for(i=0; i<length; i++)
  {
    if(ch[i] > 0x7f)
      nonasciichars++;
  }

  // if needed, release the chars again
printf("=> Entering ReleaseStringCritical ................................\n");
  (*env)->ReleaseStringCritical(env, source, ch);
printf("=> ReleaseStringCritical done ................................\n");
  return nonasciichars;

}

/*
 * Class:     JNIStringTest
 * Method:    nativeCriticalBuildOnlyAscii
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 **/
JNIEXPORT jstring JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeCriticalBuildOnlyAscii
  (JNIEnv *env, jobject obj, jstring source)
{
  jstring newstring;
  int i;

  //access the jstring UTF characters
  //get the mirror string
  jsize length = (*env)->GetStringLength(env, source);
  const jchar *ch = (*env)->GetStringCritical(env, source, 0);
  jchar* str =(jchar*)(malloc((size_t)(length*sizeof(jchar))));

  // copy jchar by jchar, replace characters > 127 (not standard ascii-7) by asterixes
  for(i=0; i<length; i++)
  {
    if(ch[i] >0x7f)
      str[i] = (jchar)'*';
    else
      str[i] = ch[i];
  }

  //assign new string
  newstring = (*env)->NewString(env, str,length);
  // Cleanup string and mirror memory
 (*env)->ReleaseStringCritical(env, source, ch);
  free(str);
  //Ok, bring in the cake
  return newstring;
}
/****************************************************************************************************************
* (GetStringCritical/ReleaseStringCritical direct in-string replacing
*/
/**
 * Class:     JNIStringTest
 * Method:    nativeCriticalReplaceNonAscii
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_gnu_testlet_wonka_jni_JNIStringTest_nativeCriticalReplaceNonAscii
  (JNIEnv *env, jobject obj, jstring source)
{
  int i;

  //access the jstring UTF characters
  //get the mirror string
  //jboolean iscopy; //always return the changed char buffer
  jsize length = (*env)->GetStringLength(env, source);
  jchar *ch = (jchar*)((*env)->GetStringCritical(env, source, 0)); // &iscopy));

  // scan jchar by jchar, replace characters > 127 (not standard ascii-7) by asterixes
  for(i=0; i<length; i++)
  {
    if(ch[i] >0x7f)
      ch[i] = (jchar)'*';
  }

  // release changed string
  // if(iscopy) => always update
  (*env)->ReleaseStringCritical(env, source, (const jchar*)ch);
  //Ok, get the goods to sender
  return source;
}

