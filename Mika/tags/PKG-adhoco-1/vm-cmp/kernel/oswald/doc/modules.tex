%
% $Id: modules.tex,v 1.1.1.1 2004/07/12 14:07:44 cvs Exp $
%

\subsection{Modules}

\subsubsection{Operation}

Modules are object code, generated by a C
compiler. By means of the support for modules in \oswald, they can be loaded when 
the kernel is already running. The module system thus enables the programmer 
to add functionality to the kernel at runtime.

This offers the kernel programmer a powerful tool:

\begin{itemize}
\item It allows to add new functionality, unknown at the moment the kernel
was started up, to be inserted without stopping it.
\item It allows to customize the behavior of the kernel at a later stage.
\item It allows to upgrade certain behavior or capabilities, without
having to statically link the code for this behavior in at the time the
kernel was compiled and linked.
\item It allows to remove certain functionality from the kernel when it is
no longer needed, to save on space and potentially CPU usage.
\end{itemize}

Since modules are in fact object files, generated by a compiler and
optionally 'prelinked' by a linker, the module code of \oswald must perform
some extra steps to make 'it run', steps which are normally performed
by the linker.

These steps can be enumerated as:

\begin{enumerate}
\item Loading the module; this means translating the format of the compiler
product object code (\oswald only supports the ELF format) into the internal
format that \oswald can work with further. This step also performs some
checks on the offered ELF data to see whether it complies with the ELF
standard.

This step of loading ELF data into the internal format is performed by calling the \txt{x\_module\_load}
function.

\item Resolving the module; this means that the names of the symbols that are either exported from
the module or imported are bound to the correct address.
This step of resolving symbols is performed by calling the \txt{x\_module\_resolve}
function.

\item The relocation step; the compiler generates code without knowing at
what memory address the code will end up in the running kernel. It therefore
generates code assuming the starting address is \txt{0x00000000} and will
produce information that will indicate at which places in the code, the real
address must be 'patched'. This information consists of 2 parts:
\begin{enumerate}
\item A symbol that describes the address that needs to be patched into this
location, i.e. the \textbf{what} goes into the patch.
\item A relocation record that describes \textbf{how} and \textbf{where} this symbol address needs
to be patched into the code.
\end{enumerate}
This process of patching is called relocation and is performed by calling the \txt{x\_module\_relocate}
function.

\item Initialization; each module must export a function that is called by
the kernel, to initialize the internal module data structures. 
Only when this step has been run successfully, the module is ready to be
used by other parts of the kernel or by other modules.
\end{enumerate}

Is is possible to change the value of a symbol after step 3, so
that module startup parametrization can be performed. To achieve this, one can
use the \txt{x\_module\_search} function to find a symbol and change its
value as needed. For initial parametrization, this must be done before step
4 of initialization.

\textbf{Sample Code}

The following is a code sample that illustrates how a module can be loaded,
resolved, relocated, initialized and how an exported function can be
searched for and called.

Note that the specifics of how the ELF data is read in from a file or from
memory is beyond the scope of the sample.

\bcode
\begin{verbatim}
  x_Module Module;
  x_module module = &Module;
  x_status status;
  int (*function)(int, int); 
  x_ubyte * elf_data;

  /*
  ** The variable 'function' is a function pointer; this 
  ** function takes two int's as arguments and returns an
  ** int as result. We assume that the variable 'elf_data' 
  ** points to an in memory image of an ELF object file.
  */

  status = x_module_load(module, elf_data, malloc, free);
  if (status != xs_success) {
    printf("Loading failed %d\n", status);
    // handle failure
  }

  status = x_module_resolve(module);
  if (status != xs_success) {
    printf("Resolving failed %d\n", status);
    // handle failure
  }

  status = x_module_relocate(module);
  if (status != xs_success) {
    printf("Relocation failed %d\n", status);
    // handle failure
  }
    
  status = x_module_init(module);
  if (status != xs_success) {
    printf("Initialization failed %d\n", status);
    // handle failure
  }

  /*
  ** Suppose that the module is known to export a function 
  ** with the name 'do_add' that adds two integers and 
  ** returns the result.
  */

  status = x_module_search(module, "do_add", &function);
  if (status == xs_success) {  
    printf("Address of 'do_add' is %p\n", function);
    printf("do_add(10, 20) = %d\n", (*function)(10, 20));
  }
  else {
    printf("Not found %d\n", status);
  }

  ...
\end{verbatim}
\ecode

\subsubsection{Brief Explanation on ELF, Resolution and Relocation}

This section will explain some elements on the ELF format that can not be
found back in the documentation or will clarify some structures. An overview
of a very simple ELF object file and how it is transformed into a memory
image is shown in figure \ref{fig:elf}.

The best way to study the ELF format is reading the documentation a few
times\footnote{I know it is hard to read, but it is the real thing...} and
using the 'objdump' command of the GNU toolset. Learn to use this command,
it's your friend.

\begin{figure}[!ht]
  \begin{center}
    \includegraphics[width=\textwidth]{elf}
    \caption{ELF Structures and the In Memory Image.\label{fig:elf}}
 \end{center}
\end{figure}

In figure \ref{fig:elf} only a few sections relevant for the following
explanation are shown, more section types exists. For more information, we
refer to the available ELF documentation. 

The following explanation is looking very repetitive but this is for the
sake of clarity. For somebody that is experienced in the art of ELF, it
will look childish\footnote{Eric, this means you shouldn't read further...}.

The very simple ELF object code of figure \ref{fig:elf} has 2 sections that
need to be translated to memory, i.e. the \txt{.text} section that
contains executable code and the \txt{.data} section that contains data
that is referred to from the executable code in the \txt{.text} section. The
assembly code that is represented in figure \ref{fig:elf} is the following small
but very useful function\footnote{Yes, I know that there is no newline in
the format string.}.

\bcode
\begin{verbatim}
void myfun(void) {
  printf("this is a string");
}
\end{verbatim}
\ecode

In the assembly code of the \txt{.text} segment, we see that the address
of \txt{printf} is not yet filled in, since the address was not known
at compile time. Also the address of the string \txt{"this is a string"}
is not yet known at compile time. The \txt{.data} section contains the
characters that make up the string.

It is important to note that the placeholder for the string address
(relocation 1) contains the 32 bit word \txt{0x00000000}, while the
placeholder for the \txt{print} call (relocation 2), contains the word
\txt{0xfffffffc} in little endian format. Written as a signed integer,
this second placeholder contains the decimal value $-4$. 

The contents of these placeholders are values that will be used in the
relocation process. In ELF speak, they are called an \textbf{addend}. In the ELF
documentation, the addend is indicated by the character \textbf{'A'}. The
addend is a value that is added during the relocation algorithm to the end
result. Note that the placeholder value $-4$ for the call is to compensate
for the fact that the program counter on a x86 architecture is pointing four
bytes further than the current instruction, so if a program counter relative value needs to be
patched into the \txt{.text} section, we need to compensate for this
program counter offset; therefore the $-4$ addend value.

The section address in the ELF image of an object file always starts at the
value \txt{0x00000000}
since the compiler does not know where in memory the image will go. In the
module code, the contents of the \txt{.text} and \txt{.data} will be
copied over into an allocated memory area. In this specific example, the
\txt{.text} section starts at \txt{0x4740} and the \txt{.data}
section immediately follows at address \txt{0x4758}. Note that some bytes
in the \txt{.text} memory area are wasted because of alignment
considerations. These alignment requirements are also given in the ELF
structure. Please refer to the TIS document for more information.

The next step, after allocating memory and copying over the relevant section
contents to that memory, is resolving the addresses of the symbols used in
the ELF data. In this specific example, there is 1 imported symbol, namely
\txt{printf}. The symbol
number 2, that refers to \txt{printf} has an undefined section and an
undefined type. The ELF standard does not care what type an undefined
element is, it could be an object or a function pointer. The module code
needs to resolve all these undefined symbols and attach them to the correct
address, i.e. it has to fill in the proper value for the undefined symbols.
These undefined symbols are searched for in the available symbol tables. If
such a symbol can not be resolved, the module can not be used. In this
specific example, the symbol value for \txt{printf} has been resolved
into the address \txt{0x00004f00}.

In the resolution step, the values for the remaining symbols also needs to
be filled in. In our example, this means adding the value of the symbol to
the in memory address of the section the symbol refers to. For symbol 1,
this means adding the value to the in memory address of the \txt{.data}
section and for symbol 3, adding the value to the \txt{.text} in memory address.
The address value of a symbol, is indicated by the character \textbf{'S'} in
the ELF standard.

From the binding information, we can also deduce that the symbol for
\txt{myfun} has binding 'global' and is thus exported from the module. It
is therefore a very good idea to make all possible definitions in the source
code static, such that only the required functions are exported (and
valuable memory space will be saved in the symbol tables).

After the resolution step, the relocation takes place. The example shows 2
relocation records. All relocation records from a .rel section, refer to the same
section that needs patching; in this example, there is only one section that
needs relocation and therefore there is only a single \txt{.rel} section.
In more complex ELF files, there can be a multitude of relocation sections
and symbol tables. In this specific example, the section that needs patching
is the \txt{.text} section. The offset of a relocation record added to
the memory address where the section is, yields the address in memory that
needs relocation, in the ELF text this is indicated by the character
\textbf{'P'}\footnote{Probably to indicate that this address needs
patching.}.

The relocation can now be performed. In our simple example, only 2 different
relocation types or algorithms are required:

\begin{itemize}
\item \txt{R\_386\_32} This is an absolute relocation, given by the
following algorithm:

$*P = A + S$

The first relocation is of this type and as one can see from the mnemonics,
it is used to push the address of the format string on the stack. Therefore
it is an absolute address and the addend is 0.

\item \txt{R\_386\_32} This is a program counter relative relocation,
given by the algorithm:

$*P = A + S - P$

This relocation type is used for the second relocation record and its result
is an argument for the \txt{call} opcode of the x86. Since this
opcode expects a relative and signed offset from the current
program counter, we need to compensate for the fact that the program counter
is already pointing 4 bytes further, therefore the $-4$ addend value or
said otherwise, P contains the value that the program counter has at the \textbf{call} instruction
plus 4 bytes.
\end{itemize}

In the example given by figure \ref{fig:elf}, note that the relocations have
NOT been performed yet in the in memory representation, i.e. the original
addends \txt{0x00000000} and \txt{0xfffffffc} are still in the in memory
data.

Note that relocation types are CPU specific, so the relocation type e.g. 4 for a
X86 CPU is not the same type as the relocation type 4 for an ARM processor!
In more complex cases as this example (e.g. shared object files and position
independent code), many more relocation types exist and sections to relocate
exist, but the principles always remain the same.

\subsubsection{Identifiers, Symbol Tables and Symbols}

An important element in the module code is the handling of symbols and
identifiers. Symbols are associations of a \textbf{name} and a \textbf{memory
address}. As indicated above, symbols play in important role in the
relocation process and to export functionality from the module to other
parts of the kernel or other modules. 

Symbols are combined in tables, called symbol tables. The name of a symbol
is called an \textbf{identifier} in \oswald. How identifiers, symbol tables
and symbols relate to each other is explained in figure \ref{fig:symbols}.

\begin{figure}[!ht]
  \begin{center}
    \rotatebox{270}{\includegraphics[height=0.65\textheight]{symbols}}
    \caption{Relation between identifiers, symbol tables and symbols.\label{fig:symbols}}
 \end{center}
\end{figure}

Figure \ref{fig:symbols} shows how the identifier for the \txt{printf} symbol is
linked into the hashtable and points to all the symbols that have the same
identifier. If the \txt{x\_ident$\rightarrow$symbols} field is traced
through the dashed and dotted line, the first symbol encountered defines the
address of the \txt{printf} function and links further through the
\txt{x\_symbol$\rightarrow$next} field to two other symbols that refer to
this symbol to define the address value of \txt{printf}. This is indicated by
the fact that these two symbols refer back to the first, by means of the
dotted line and their \txt{x\_symbol$\rightarrow$value.defines} fields.
Also note that all the symbols refer to the identifier for \txt{printf}
through their \txt{x\_symbol$\rightarrow$ident} field.

The first symbol table, the one that contains the symbol definition of the
\txt{printf} function, has its \txt{x\_symtab$\rightarrow$module}
field pointing to \txt{NULL} indicating that this symbol table belongs to
the kernel itself and contains kernel exported function addresses.

In the following paragraphs, the structures for identifiers, symbol tables
and symbols will be explained in more detail.

%\newpage
\textbf{Identifier Structure Definition}

The structure definition of an identifier is as follows:

\bcode
\begin{verbatim}
 1: typedef struct x_Ident * x_ident;
 2:
 3: typedef struct x_Ident {
 4:   x_ident next;
 5:   x_symbol symbols;
 6:   x_ubyte string[0];
18: } x_Ident;
\end{verbatim}
\ecode

The relevant fields in the identifier structure are the following:

\begin{itemize}
\item \txt{x\_ident$\rightarrow$next} All identifiers in the module code
are unique. To look up identifiers, they are kept in a hashtable and entries
with the same hash value are 'chained'. This field chains this identifier to
the next identifier with the same hash value.
\item \txt{x\_ident$\rightarrow$symbols} A symbol is defined later on.
The list of symbols that have the same identifier starts with this field.
\item \txt{x\_ident$\rightarrow$string} The identifier structure is a
variable sized structure and the end of the structure is used to store the
ASCII characters that make up the string representation of the name.
\end{itemize}

\textbf{Symbol Table Structure Definition}

The structure definition of a symbol table is as follows:

\bcode
\begin{verbatim}
 1: typedef struct x_Symtab * x_symtab;
 2:
 3: typedef struct x_Symtab {
 4:   x_symtab next;
 5:   x_module module;
 6:   x_int num_symbols;
 7:   x_int capacity;
 8:   x_uword madgic;
 9:   x_Symbol symbols[0];
18: } x_Symtab;
\end{verbatim}
\ecode

The relevant fields in the symtab structure are the following:

\begin{itemize}
\item \txt{x\_symtab$\rightarrow$next} Symbol tables are kept in a linked
list and this field is used to chain further to the next symbol table in the
list.

\item \txt{x\_symtab$\rightarrow$module} Symbol tables are associated
with a module. The module either exports or imports the symbols that are in
its symbol table. There is only one case where this field contains NULL, and
this is when a symbol table is associated with symbols exported by the
kernel. Note that the kernel symbol table only exports symbols.

\item \txt{x\_symtab$\rightarrow$num\_symbols} This field contains the
number of symbols that are available in the symbol table.

\item \txt{x\_symtab$\rightarrow$capacity} Some symbol tables are
allocated with a certain number of free slots, to fill in later. This field
total number of slots that are available in the symbol table. The number of
available slots is found from \txt{capacity} - \txt{num\_symbols}.

\item \txt{x\_symtab$\rightarrow$madgic} There is a function
\txt{x\_symbol2symtab} that can be used to find back the symbol table
from a symbol reference. This field is used as a fencepost to help this
function; it indicates the start of the array of \txt{x\_Symbol} elements
in the \txt{x\_Symtab} structure.

\item \txt{x\_symtab$\rightarrow$symbols} This is the array of
\txt{x\_Symbol} structures that are part of the symbol table.
\end{itemize}

\textbf{Symbol Structure Definition}

The structure definition of a symbol is as follows:

\bcode
\begin{verbatim}
 1: typedef struct x_Symbol * x_symbol;
 2:
 3: typedef struct x_Symbol {
 4:   x_symbol next;
 5:   x_ident ident;
 6:   x_flags flags;
 7:   union {
 8:     x_address address;
 9:     x_symbol defines;
10:   } value;
18: } x_Symbol;
\end{verbatim}
\ecode

The relevant fields in the symbol structure are the following:

\begin{itemize}
\item \txt{x\_symbol$\rightarrow$next} This is the field that chains to
the next symbol with the same identifier.

\item \txt{x\_symbol$\rightarrow$ident} This is the reference back to the
identifier that is the name of the symbol.

\item \txt{x\_symbol$\rightarrow$flags} Symbols can carry different flags
to indicate e.g. which field of the \txt{value} union is valid. Also the
number of referrals to this symbol is stored in the lower bits of the
\txt{flags} field. The number of referrals only applies to symbols that
define an address and indicates how many other symbols rely on this symbol
to define the address.

The most important flags are:
\begin{enumerate}
\item \txt{SYM\_EXPORTED} This symbol defines a memory address, i.e. the
\txt{value.address} field is valid.
\item \txt{SYM\_IMPORTED} The symbol refers to another symbol that defines
the address value, i.e. the \txt{value.defines} field is valid and points
to the defining symbol.
\item \txt{SYM\_RESOLVED} The symbol has been set up properly and is bound
to either and address or to the symbol that defines the address.
\item \txt{SYM\_FUNCTION} The symbol refers to a function pointer.
\item \txt{SYM\_VARIABLE} The symbol refers to a data object.
\item \txt{SYM\_SPECIAL} The symbol refers to a special object or function
pointer like e.g. the initializer function, or other internally used
elements. 
\end{enumerate}

More flags are possible for which we refer to the source code of the module
functionality.

\item \txt{x\_symbol$\rightarrow$value.address} This is the address
location that is associated with the symbol.

\item \txt{x\_symbol$\rightarrow$value.defines} When a symbol refers to
another defining symbol, this field is the reference to the symbol that
defines the address.
\end{itemize}

\subsubsection{Loading a Module}

Loading is the initial step in transforming ELF compliant data (e.g. an ELF object
file) into a module that can be used by \oswald.

A module is initially loaded by means of the following call:

\txt{x\_status x\_module\_load(x\_module module, x\_ubyte * elf\_data, x\_malloc a, x\_free f);}

The different return values that this call can produce are summarized
in table \ref{table:module_load}.

\oswald assumes that the passed pointer \txt{elf\_data} is a single chunk
of memory that contains all the objects file data and considers it read only
data. This enables the programmer that wants to package the kernel to put
this data in read only memory.
The ELF structures that are part of the data and that need to be modified,
will be copied over into runtime modifiable structures.

\footnotesize
\begin{longtable}{||l|p{9cm}||}
\hline
\hfill \textbf{Return Value} \hfill\null & \textbf{Meaning}  \\ 
\hline
\endhead
\hline
\endfoot
\endlastfoot
\hline


% \begin{table}[!ht]
%   \begin{center}
%     \begin{tabular}{||>{\footnotesize}l<{\normalsize}|>{\footnotesize}c<{\normalsize}||} \hline
%     \textbf{Return Value} & \textbf{Meaning} \\ \hline

\txt{xs\_success} &
\begin{minipage}[t]{9cm}
The loading was successful and the subsequent step of resolution can be taken for preparing
the module further. The \txt{MOD\_LOADED} flag is set after successful
return.
\end{minipage} \\

\txt{xs\_no\_mem} &
\begin{minipage}[t]{9cm}
In allocating memory for its internal structures, the function encountered a
NULL reply from the allocation function. Nothing of the potentially already allocated
memory is freed.
\end{minipage} \\

\txt{xs\_not\_elf} &
\begin{minipage}[t]{9cm}
In checking the internal consistency of the ELF file, or in checking the
version of the ELF ABI that this code supports, a discrepancy was found. No
further processing can be done on this module.
\end{minipage} \\


\hline 
\multicolumn{2}{c}{} \\
\caption{Return Status for \txt{x\_module\_load}}
\label{table:module_load}
\end{longtable}
\normalsize


%     \hline
%     \end{tabular}
%     \caption{Return Status for \txt{x\_module\_load}}
%     \label{table:module_load}
%   \end{center}
% \end{table}

\subsubsection{Resolving a Module}

A module can be resolved with the following call:

\txt{x\_status x\_module\_resolve(x\_module module);}

The different return values that this call can produce are summarized
in table \ref{table:module_resolve}.  

\footnotesize
\begin{longtable}{||l|p{9cm}||}
\hline
\hfill \textbf{Return Value} \hfill\null & \textbf{Meaning}  \\ 
\hline
\endhead
\hline
\endfoot
\endlastfoot
\hline

% \begin{table}[!ht]
%   \begin{center}
%     \begin{tabular}{||>{\footnotesize}l<{\normalsize}|>{\footnotesize}c<{\normalsize}||} \hline
%     \textbf{Return Value} & \textbf{Meaning} \\ \hline

\txt{xs\_success} &
\begin{minipage}[t]{9cm}
The module symbols have been successfully resolved and are linked up with
the proper addresses. Calling this function for a module that has been
resolved already also yields this return value. As a result the
\txt{MOD\_RESOLVED} flag is set.
\end{minipage} \\

\txt{xs\_seq\_error} &
\begin{minipage}[t]{9cm}
An error occurred because the module was not yet loaded, i.e. the
\txt{MOD\_LOADED} flag was not set for this module.
\end{minipage} \\

\txt{xs\_no\_symbol} &
\begin{minipage}[t]{9cm}
A symbol that is imported by the module could not be found back in the
existing symbol tables. Maybe additional modules need to be loaded to define
the missing symbol.
\end{minipage} \\


\hline 
\multicolumn{2}{c}{} \\
\caption{Return Status for \txt{x\_module\_resolve}}
\label{table:module_resolve}
\end{longtable}
\normalsize


%     \hline
%     \end{tabular}
%     \caption{Return Status for \txt{x\_module\_resolve}}
%     \label{table:module_resolve}
%   \end{center}
% \end{table}

\subsubsection{Relocating a Module}

A module can be relocated with the following call:

\txt{x\_status x\_module\_relocate(x\_module module);}

The different return values that this call can produce are summarized
in table \ref{table:module_relocate}.  

\footnotesize
\begin{longtable}{||l|p{9cm}||}
\hline
\hfill \textbf{Return Value} \hfill\null & \textbf{Meaning}  \\ 
\hline
\endhead
\hline
\endfoot
\endlastfoot
\hline


% \begin{table}[!ht]
%   \begin{center}
%     \begin{tabular}{||>{\footnotesize}l<{\normalsize}|>{\footnotesize}c<{\normalsize}||} \hline
%     \textbf{Return Value} & \textbf{Meaning} \\ \hline

\txt{xs\_success} &
\begin{minipage}[t]{9cm}
Information on the return value.
\end{minipage} \\


\hline 
\multicolumn{2}{c}{} \\
\caption{Return Status for \txt{x\_module\_relocate}}
\label{table:module_relocate}
\end{longtable}
\normalsize


%     \hline
%     \end{tabular}
%     \caption{Return Status for \txt{x\_module\_relocate}}
%     \label{table:module_relocate}
%   \end{center}
% \end{table}

\subsubsection{Initializing a Module}

A module can be initialized with the following call:

\txt{x\_status x\_module\_initialize(x\_module module);}

The different return values that this call can produce are summarized
in table \ref{table:module_initialize}.  


\footnotesize
\begin{longtable}{||l|p{9cm}||}
\hline
\hfill \textbf{Return Value} \hfill\null & \textbf{Meaning}  \\ 
\hline
\endhead
\hline
\endfoot
\endlastfoot
\hline


% \begin{table}[!ht]
%   \begin{center}
%     \begin{tabular}{||>{\footnotesize}l<{\normalsize}|>{\footnotesize}c<{\normalsize}||} \hline
%     \textbf{Return Value} & \textbf{Meaning} \\ \hline

\txt{xs\_success} &
\begin{minipage}[t]{9cm}
Information on the return value.
\end{minipage} \\



\hline 
\multicolumn{2}{c}{} \\
\caption{Return Status for \txt{x\_module\_initialize}}
\label{table:module_initialize}
\end{longtable}
\normalsize

%     \hline
%     \end{tabular}
%     \caption{Return Status for \txt{x\_module\_initialize}}
%     \label{table:module_initialize}
%   \end{center}
% \end{table}

\subsubsection{Searching for an Exported Symbol}

A certain function address can be searched for in a module with the following call:

\txt{x\_status x\_module\_search(x\_module module, const char * name, void ** address);}

The different return values that this call can produce are summarized
in table \ref{table:module_search}.  

\footnotesize
\begin{longtable}{||l|p{9cm}||}
\hline
\hfill \textbf{Return Value} \hfill\null & \textbf{Meaning}  \\ 
\hline
\endhead
\hline
\endfoot
\endlastfoot
\hline


% \begin{table}[!ht]
%   \begin{center}
%     \begin{tabular}{||>{\footnotesize}l<{\normalsize}|>{\footnotesize}c<{\normalsize}||} \hline
%     \textbf{Return Value} & \textbf{Meaning} \\ \hline

\txt{xs\_success} &
\begin{minipage}[t]{9cm}
Information on the return value.
\end{minipage} \\


\hline 
\multicolumn{2}{c}{} \\
\caption{Return Status for \txt{x\_module\_search}}
\label{table:module_search}
\end{longtable}
\normalsize

%     \hline
%     \end{tabular}
%     \caption{Return Status for \txt{x\_module\_search}}
%     \label{table:module_search}
%   \end{center}
% \end{table}

\subsubsection{Parsing a Function Identifier for JNI}

The module code of \oswald offers a utility function that can parse the
function identifier into the appropriate components for interfacing with a
JNI system.

The JNI utility 'javah' will read Java class files that contain declarations
of native functions and will generate the appropriate header file and
signatures to be used in C code. Since Java has the capabilities of
overloading methods and C has not, there is a translation step taking from
the Java naming methods into an C style naming.

For instance, the overloaded Java class methods:

\txt{My\_Peer.destroy(char b[], int i, String s)}

\txt{My\_Peer.destroy(long j, char b[], int i, String s)} 

is translated into function names that are acceptable in C:

\txt{Java\_My\_1Peer\_destroy\_\_\_3BILjava\_lang\_String\_2}

\txt{Java\_My\_1Peer\_destroy\_\_J\_3BILjava\_lang\_String\_2}

I.e. the Java method names are mangled.
The specifics of this mangling are outside of the scope of this
document. Any good book on JNI will go into the details of this name
mangling.

\oswald offers a utility function \txt{x\_symbol\_java} that helps in
translating the C style function names back into the appropriate Java
conventions that can be used inside a virtual machine. This function is:

\txt{x\_int x\_symbol\_java(x\_symbol symbol, unsigned char * buffer, x\_size num);}

The arguments are the \txt{symbol} that needs parsing, a \txt{buffer} and the size of
this buffer in \txt{num}. The function will return the number of
characters that are used in the buffer. This function will check for
overflow of the buffer. The buffer is filled with 3 components of the
function name:

\begin{enumerate}
\item The name of the class, in this case 'My\_Peer', as a nul terminated
character string, that begins at \txt{buffer + buffer[0]}. The length of
the class name without the trailing nul character included is stored in
\txt{buffer + buffer[1]}.
\item The name of the method, in this case 'destroy', as a nul terminated
character string, that begins at \txt{buffer + buffer[2]}. The length of
the method name without the trailing nul character included is stored in
\txt{buffer + buffer[3]}.
\item The signature of the arguments, as a nul terminated character string.
For the first example this is '([BILjava/lang/String;)',
and for the second this is '(J[BILjava/lang/String;)'. The string begins at \txt{buffer + buffer[4]}. The length of
the argument signature without the trailing nul character included is stored in
\txt{buffer + buffer[5]}.
\end{enumerate}

So the first 6 positions of the \txt{buffer} array of characters are used
as indexes into this array and the lengths of the strings. This limits the
lengths and indexes to be less than 255.

Also note that the argument signature component of the buffer is written in the
descriptor format of the Java Virtual Machine specification, but without the
return type\footnote{This is no limitation since Java overloaded methods
must all return the same type.}.

When this function is called on a symbol that does not represent a Java
native method function name, i.e. a name that doesn't begin with
'Java\_', the returned result is 0.

%\bibliographystyle{natbib}
%\bibliography{modules}



