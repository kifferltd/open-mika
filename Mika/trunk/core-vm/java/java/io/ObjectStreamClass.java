/**************************************************************************
* Copyright (c) 2001 by Punch Telematix. All rights reserved.             *
*                                                                         *
* Redistribution and use in source and binary forms, with or without      *
* modification, are permitted provided that the following conditions      *
* are met:                                                                *
* 1. Redistributions of source code must retain the above copyright       *
*    notice, this list of conditions and the following disclaimer.        *
* 2. Redistributions in binary form must reproduce the above copyright    *
*    notice, this list of conditions and the following disclaimer in the  *
*    documentation and/or other materials provided with the distribution. *
* 3. Neither the name of Punch Telematix nor the names of                 *
*    other contributors may be used to endorse or promote products        *
*    derived from this software without specific prior written permission.*
*                                                                         *
* THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED          *
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF    *
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.    *
* IN NO EVENT SHALL PUNCH TELEMATIX OR OTHER CONTRIBUTORS BE LIABLE       *
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR            *
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    *
* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR         *
* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,   *
* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE    *
* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN  *
* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                           *
**************************************************************************/

/*
** $Id: ObjectStreamClass.java,v 1.1.1.1 2004/07/12 14:07:45 cvs Exp $
*/

package java.io;

import java.util.WeakHashMap;
import java.lang.reflect.Method;
import java.util.Arrays;

/**
** ObjectStreamClasses can only be generated by user code through the static lookup method.
** In this case ObjectStreamClass will be initialized completly.  Wonka's own code also needs to
** create ObjectStreamClasses especially in the ObjectInputStream code. We have to make sure all
** of these ObjectStreamClasses are initialized before we use them. (or at least as much as possible)
**
*/
public class ObjectStreamClass implements Serializable {

  private static final long serialVersionUID = -6120832682080437368L;

  public static final ObjectStreamField[] NO_FIELDS = new ObjectStreamField[0];

  /** extra flags used to indicate the state of the ObjectStreamClass.
      These values are used native, is you change them here also change the native part
  */
  static final int IS_ARRAY    = 0x01000000;
  static final int IS_BAD      = 0x00800000;
  static final int IS_NOT_SER  = 0x00400000;
  static final int WRONG_SUID  = 0x00200000;

  private static WeakHashMap streamClassCache = new WeakHashMap();

  private native static ObjectStreamClass createObjectStreamClass(Class cl);

  /**
  ** this cache can grow and eat up resources ...
  */
  public static ObjectStreamClass lookup(Class cl){
    ObjectStreamClass o = (ObjectStreamClass) streamClassCache.get(cl);
    if(o == null){
      o = createObjectStreamClass(cl);
      if(o != null){
        o.name = cl.getName();
        streamClassCache.put(cl,o);
        ObjectStreamClass current = o;
        ObjectStreamClass parent;
        do {
          cl = cl.getSuperclass();
          parent = (ObjectStreamClass) streamClassCache.get(cl);
          if(parent == null){
            parent = createObjectStreamClass(cl);
            if(parent == null){
              break;
            }
            current.parent = parent;
            streamClassCache.put(cl,parent);
            parent.name = cl.getName();
            current = parent;
          }
          else {
            current.parent = parent;
            break;
          }

        } while (true);
      }
    }
    return o;
  }

  /** set by lookup */
  String name;
  ObjectStreamClass parent;

  /** set in native method createObjectStreamClass(Class cl) */
  long suid;
  Class clazz;
  int flags;
  Method writeObject;
  Method writeReplace;

  /** set by verifyInput, can only be used by ObjectInputStream */
  Method readObject;
  Method readResolve;

  /** set in getFields or set by the ObjectInputStream (in this case they don't reflect the fields
      of the local class but data gathered from the inputstream)
  */
  ObjectStreamField[] osFields;

  ObjectStreamClass(String name){
    this.name = name;
  }

  ObjectStreamClass(String name, long suid, int flags) {
    this.name = name;
    this.suid = suid;
    this.flags = flags;
  }

  public Class forClass() {
    return clazz;
  }

  public ObjectStreamField getField(String name){
    ObjectStreamField[] fields = this.osFields;
    if(fields == null){
      fields = getFields();
      this.osFields = fields;
    }
    int l = fields.length;
    for(int i = 0 ; i < l ; i++){
      if(name.equals(fields[i].name)){
        return fields[i];
      }
    }
    return null;
  }

  public ObjectStreamField[] getFields(){
    if(osFields == null){
      ObjectStreamField[] flds = createFields();
      if(flds == null){
        flds = NO_FIELDS;
      }
      else {
        Arrays.sort(flds);
      }
      osFields = flds;
    }
    return osFields;
  }

  public String getName() {
    return name;
  }

  public long getSerialVersionUID() {
    return suid;
  }

  public String toString() {
    return "ObjectStreamClass: '"+name+"' SUID = "+suid;
  }

  native void verifyInput() throws IOException;

  private native ObjectStreamField[] createFields();
}
