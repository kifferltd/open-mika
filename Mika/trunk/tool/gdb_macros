###########################################################################
# Copyright  (c) 2001 by Acunia N.V. All rights reserved.                 #
#                                                                         #
# This software is copyrighted by and is the sole property of Acunia N.V. #
# and its licensors, if any. All rights, title, ownership, or other       #
# interests in the software remain the property of Acunia N.V. and its    #
# licensors, if any.                                                      #
#                                                                         #
# This software may only be used in accordance with the corresponding     #
# license agreement. Any unauthorized use, duplication, transmission,     #
#  distribution or disclosure of this software is expressly forbidden.    #
#                                                                         #
# This Copyright notice may not be removed or modified without prior      #
# written consent of Acunia N.V.                                          #
#                                                                         #
# Acunia N.V. reserves the right to modify this software without notice.  #
#                                                                         #
#   Acunia N.V.                                                           #
#   Vanden Tymplestraat 35      info@acunia.com                           #
#   3000 Leuven                 http://www.acunia.com                     #
#   Belgium - EUROPE                                                      #
###########################################################################

#
# $Id: gdb_macros,v 1.1.1.1 2004/07/12 14:07:44 cvs Exp $
#
# -= Macros for helping with debugging Wonka =-
#
# Add these to your .gdbinit file or load them with
# 'source /path/to/gdb_macros'
#

handle SIG33 nostop pass noprint
handle SIGIO nostop pass
handle SIGQUIT nostop pass

# 
# Print the w_object if you have the address of an instance.
#

define instance2object
  print (w_object)((char *)$arg0 - sizeof(w_Object))
  end

#
# Print the address of an instance if you have the address of 
# an object
#

define object2instance
  print/x (unsigned int)((char *)$arg0 + sizeof(w_Object))
  end

#
# Print the address of a clazz if you the address of an instance
#

define instance2clazz
  print ((w_object)((char *)$arg0 - sizeof(w_Object)))->clazz
  end

#
# Print information about a w_method
#

define printm
  printw ((w_method)$arg0)->spec.name
  printw ((w_method)$arg0)->spec.declaring_clazz->dotified
  end
  
document printm
  Print information about a w_method
  end

#
# Print the type of an instance
#

define printi
  print (w_string)((w_object)((char *)$arg0 - sizeof(w_Object)))->clazz->dotified
  printw $
  end

document printi
  Print the type of an instance.
  end

#
# Print a w_string. 
# Since this interpreted macro goes pretty slow, it's recommended to use
# 'call printw("%w\n", <w_string>)' to print a w_string, but this works
# only if wonka hasn't died. The printw is a post mortum alternative.
#

define printw
  set var $i=0
  while ($i != ((w_string)$arg0)->length)
    printf "%c", ((w_string)$arg0)->chars[$i]
    set var $i=$i+1
    end
  printf "\n"
  end

document printw
  Print a Wonka string.
  end

#
# Load the runtime symbols generated by J-Spot.
#

define runtime-symbols
  shell as fsroot/runtime-stabs.s -o runtime-stabs.o
  add-symbol-file runtime-stabs.o 0
  end

#
# Render and display a JIT compiled function's flow graph.
#

define dot 
  shell dot -Tps -Gsize=7,9 "fsroot/user/dot/$arg0.dot" -o dot.ps
  shell gv dot.ps &
  end

#
# Get GDB in a clean state. This is useful when you want to 
# call functions inside wonka. You don't want it to be in the
# idle thread or in some libc function for obvious reasons.
#

define clean_state
  break interprete
  continue
  end

document clean_state
  Get GDB in a clean state. This is useful when you want to 
  call functions inside wonka. You don't want it to be in the
  idle thread or in some libc function for obvious reasons.
  end

#
# Get an oswald thread from a wonka thread
#

define wt2xt 
  print (x_thread)(((w_thread)$arg0)->kthread)
  end

document wt2xt
  Get an Oswald thread from a Wonka thread.
  end

#
# Get a wonka thread from an oswald thread
#

define xt2wt
  print (w_thread)(((x_thread)$arg0)->xref)
  end

document xt2wt
  Get a Wonka thread from an Oswald thread.
  end

#
# Pretty print an oswald thread.
#

define printxthread
  printf "id: %2d   priority: %2d   ", ((x_thread)$arg0)->id, $arg1
  print (x_thread)$arg0
  end

#
# Get a list of all the oswald threads
#

define xthreads
  printf "Current : "
  print thread_current

  set var $i = 0
  while ($i < 64)
    set var $pcb = pcbs[$i]

    set var $t = $pcb->t_ready
    if ($t != 0)
      printf "Ready :   "
      printxthread $t $i
      set var $t = $t->next
      while ($t != $pcb->t_ready) 
        printf "Ready :   "
        printxthread $t $i
        set var $t = $t->next
        end
      end
    set var $i = $i + 1
    
    set var $t = $pcb->t_pending
    if ($t != 0)
      printf "Pending : "
      printxthread $t $i
      set var $t = $t->next
      while ($t != $pcb->t_pending) 
        printf "Pending : "
        printxthread $t $i
        set var $t = $t->next
        end
      end
    set var $i = $i + 1
    
    end
  end
 
document xthreads
  Show a list of all the Oswald threads.
  end
  
#
# Switch oswald threads
#

set var $oldesp = 0
set var $oldebp = 0
set var $oldeip = 0

define xthread
  if ($oldesp == 0)
    set var $oldesp = $esp
    set var $oldebp = $ebp
    set var $oldeip = $eip
  end
    
  if ($arg0 == thread_current) 
    set var $esp = $oldesp
    set var $ebp = $oldebp
    set var $eip = $oldeip
    set var $oldesp = 0
    set var $oldebp = 0
    set var $oldeip = 0
  else 
    set $esp = ((x_thread)$arg0)->cpu.sp
    set $ebp = $esp + 16
    set $eip = *(unsigned int *)($ebp + 4)
    end
  end

document xthread
  Switch the specified Oswald thread. 
  end

#
# A hook for the 'continue' command. This makes sure that the 
# current thread is restored.
#

define hook-continue
#  clear interprete
  xthread thread_current
  end

document hook-continue
  A hook for the 'continue' command.  This makes sure that the current thread is restored.
  end

define mem2wchunk
  print ((w_chunk)((char *)$arg0 - 24))
  end

define mem2xchunk
  print ((x_chunk)((char *)$arg0 - 8))
  end

define xmem_size 
  print (((((x_chunk)$arg0)->this_size & 0x000fffff) << 3) - 4)
  end
